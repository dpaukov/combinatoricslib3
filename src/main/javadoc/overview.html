<html>
<head>
</head>
<body>

Combinatoricslib 3 is a Java library for generating combinatorial objects of any types

<h2>Features</h2>
<ol>
	<li>Library contains generic vectors and generators. So it may generate combinatorial objects of any types. Type of the elements has to be specified as a parameter</li>
	<li>Library can generate the following combinatorial objects:
		<ul>
			<li>All possible simple combinations of a vector</li>
			<li>All possible multi-combinations (with repetitions) of a vector</li>
			<li>All possible permutations with and without repetitions (tuples) of a vector</li>
			<li>All possible sub-sets of a set or a list (with duplicates)</li>
			<li>All possible compositions of an integer value</li>
			<li>All possible partitions of an integer value</li>
			<li>All possible partitions of a list as non-overlapping sublists</li>
		</ul>
	</li>
	<li>Library supports filtering the generated vectors</li>
	<li>All generators can be used in the "for-each" loops</li>
	
</ol>

<h3> 1. Simple permutations </h3>
A permutation is an ordering of a set in the context of all possible orderings. For example, the set containing the first three digits, 123, has
six permutations: 123, 132, 213, 231, 312, and 321.
<p>
This is an example of the permutations of 3 string items (apple, orange, cherry):
<p>
<blockquote>
<pre>
// Create the initial vector of 3 elements (apple, orange, cherry)
ICombinatoricsVector&lt;String&gt; originalVector = Factory.createVector(new String[] { &quot;apple&quot;, &quot;orange&quot;, &quot;cherry&quot; });

// Create the permutation generator by calling the appropriate method of the Factory class
Generator&lt;String&gt; gen = Factory.createPermutationGenerator(originalVector);

// Print the result
for (ICombinatoricsVector&lt;String&gt; perm : gen)
	System.out.println(perm);
</pre>
</blockquote>

<p>
And the result
<p>
<blockquote>
<pre>
  CombinatoricsVector=([apple, orange, cherry], size=3)
  CombinatoricsVector=([apple, cherry, orange], size=3)
  CombinatoricsVector=([cherry, apple, orange], size=3)
  CombinatoricsVector=([cherry, orange, apple], size=3)
  CombinatoricsVector=([orange, cherry, apple], size=3)
  CombinatoricsVector=([orange, apple, cherry], size=3)
</pre>
</blockquote>
<p>

<h3> 2. Permutations with repetitions </h3>
<p>
The permutation may have more elements than slots. For example, the three
possible permutation of 12 in three slots are: 111, 211, 121, 221, 112, 212,
122, and 222.
<p>
Let's generate all possible permutations with repetitions of 3 elements from
the set of apple and orange:
<p>
<blockquote>
<pre>
// Create the initial vector of 2 elements (apple, orange)
ICombinatoricsVector&lt;String&gt; originalVector = Factory.createVector(new String[] { &quot;apple&quot;, &quot;orange&quot; });

// Create the generator by calling the appropriate method in the Factory class. 
// Set the second parameter as 3, since we will generate 3-elemets permutations
Generator&lt;String&gt; gen = Factory.createPermutationWithRepetitionGenerator(originalVector, 3);

// Print the result
for (ICombinatoricsVector&lt;String&gt; perm : gen)
   System.out.println( perm );
</pre>
</blockquote>
<p>
And the result
<p>
<blockquote>
<pre>
  CombinatoricsVector=([apple, apple, apple], size=3)
  CombinatoricsVector=([orange, apple, apple], size=3)
  CombinatoricsVector=([apple, orange, apple], size=3)
  CombinatoricsVector=([orange, orange, apple], size=3)
  CombinatoricsVector=([apple, apple, orange], size=3)
  CombinatoricsVector=([orange, apple, orange], size=3)
  CombinatoricsVector=([apple, orange, orange], size=3)
  CombinatoricsVector=([orange, orange, orange], size=3)
</pre>
</blockquote>
<p>

<h3> 3. Simple combinations</h3>
<p>
A simple k-combination of a finite set S is a subset of k distinct elements
of S. Specifying a subset does not arrange them in a particular order. As an
example, a poker hand can be described as a 5-combination of cards from a
52-card deck: the 5 cards of the hand are all distinct, and the order of the
cards in the hand does not matter.
<p>
For example, let's generate 3-combination of the set (red, black, white, green, blue).
<p>
<blockquote>
<pre>
// Create the initial vector
ICombinatoricsVector&lt;String&gt; initialVector = Factory.createVector(new String[] {
		&quot;red&quot;, &quot;black&quot;, &quot;white&quot;, &quot;green&quot;, &quot;blue&quot; });

// Create a simple combination generator to generate 3-combinations of the
// initial vector
Generator&lt;String&gt; gen = Factory.createSimpleCombinationGenerator(initialVector, 3);

// Print all possible combinations
for (ICombinatoricsVector&lt;String&gt; combination : gen) {
	System.out.println(combination);
}
</pre>
</blockquote>
<p>
And the result of 10 combinations
<p>
<blockquote>
<pre>
   CombinatoricsVector=([red, black, white], size=3)
   CombinatoricsVector=([red, black, green], size=3)
   CombinatoricsVector=([red, black, blue], size=3)
   CombinatoricsVector=([red, white, green], size=3)
   CombinatoricsVector=([red, white, blue], size=3)
   CombinatoricsVector=([red, green, blue], size=3)
   CombinatoricsVector=([black, white, green], size=3)
   CombinatoricsVector=([black, white, blue], size=3)
   CombinatoricsVector=([black, green, blue], size=3)
   CombinatoricsVector=([white, green, blue], size=3)
</pre>
</blockquote>
<p>

<h3> 4. Multi-combinations</h3>

A k-multicombination or k-combination with repetition of a finite set S is
given by a sequence of k not necessarily distinct elements of S, where order
is not taken into account.
<p>
As an example. Suppose there are 2 types of fruits (apple and orange) at a
grocery store, and you want to buy 3 pieces of fruit. You could select
<ul>
<li>(apple, apple, apple)
<li>(apple, apple, orange)
<li>(apple, orange, orange)
<li>(orange, orange, orange)
</ul>
<p>
Generate 3-combinations with repetitions of the set (apple, orange).
<p>
<p>
<blockquote>
<pre>
// Create the initial vector of (apple, orange)
ICombinatoricsVector&lt;String&gt; initialVector = Factory.createVector(new String[] {
		&quot;apple&quot;, &quot;orange&quot; });

// Create a multi-combination generator to generate 3-combinations of
// the initial vector
Generator&lt;String&gt; gen = Factory.createMultiCombinationGenerator(initialVector,3);
 
// Print all possible combinations
for (ICombinatoricsVector&lt;String&gt; combination : gen) {
	System.out.println(combination);
}
</pre>
</blockquote>
<p>
And the result of 4 multi-combinations
<p>
<blockquote>
<pre>
   CombinatoricsVector=([apple, apple, apple], size=3)
   CombinatoricsVector=([apple, apple, orange], size=3)
   CombinatoricsVector=([apple, orange, orange], size=3)
   CombinatoricsVector=([orange, orange, orange], size=3)
</pre>
</blockquote>
<p>

<h3> 5. Subsets</h3>
<p>
A set A is a subset of a set B if A is "contained" inside B. A and B may
coincide. The relationship of one set being a subset of another is called
inclusion or sometimes containment.
<p>
Examples:
<ul>
<li>The set (1, 2) is a proper subset of (1, 2, 3).
<li>Any set is a subset of itself, but not a proper subset.
<li>The empty set, denoted by (), is also a subset of any given set X.
</ul>
<p>
All subsets of (1, 2, 3) are:
<ol>
<li>()
<li>(1)
<li>(2)
<li>(1, 2)
<li>(3)
<li>(1, 3)
<li>(2, 3)
<li>(1, 2, 3)
</ol>
<p>
And code which generates all subsets of (one, two, three)
<p>
<blockquote>
<pre>
// Create an initial vector/set
ICombinatoricsVector&lt;String&gt; initialSet = Factory.createVector(new String[] {
		&quot;one&quot;, &quot;two&quot;, &quot;three&quot; });

// Create an instance of the subset generator
Generator&lt;String&gt; gen = Factory.createSubSetGenerator(initialSet);

// Print the subsets
for (ICombinatoricsVector&lt;String&gt; subSet : gen) {
	System.out.println(subSet);
}
</pre>

</blockquote>
<p>
And the result of all 8 possible subsets
<p>
<blockquote>

<pre>
 CombinatoricsVector=([], size=0)
 CombinatoricsVector=([one], size=1)
 CombinatoricsVector=([two], size=1)
 CombinatoricsVector=([one, two], size=2)
 CombinatoricsVector=([three], size=1)
 CombinatoricsVector=([one, three], size=2)
 CombinatoricsVector=([two, three], size=2)
 CombinatoricsVector=([one, two, three], size=3)
</pre>

</blockquote>
<p>
Version 2.0 of the combinatoricslib supports sets with duplicates. For
example, if the original vector contains duplicates like (a, b, a, c), then
the result will contain 14 subsets (instead of 16): <blockquote>

<pre>
()
(a)
(b)
(a, b)
(a, a)
(b, a)
(a, b, a)
(c)
(a, c)
(b, c)
(a, b, c)
(a, a, c)
(b, a, c)
(a, b, a, c)
</pre>
</blockquote>
<p>
If you still would like to treat the set with duplicates as not identical,
you should create a generator and set the second parameter of the method
<code>Factory.createSubSetGenerator()</code> as <code>false</code>. In this
case all 16 subsets will be generated.
<p>
<b>Note.</b> If the initial vector contains duplicates then the method
<code>getNumberOfGeneratedObjects</code> won't be able to return the number
of the sub sets/lists. It will throw a runtime exception
<p>

<h3>6. Integer partitions</h3>
<p> 
In number theory, a partition of a positive integer n is a way of writing n
as a sum of positive integers. Two sums that differ only in the order of
their summands are considered to be the same partition; if order matters then
the sum becomes a composition. A summand in a partition is also called a
part.
<p>
<b>WARNING!</b> Be careful because number of all partitions can be very high even
for not great given N.
<p>
The partitions of 5 are listed below:
<ol>
<li>1 + 1 + 1 + 1 + 1
<li>2 + 1 + 1 + 1
<li>2 + 2 + 1
<li>3 + 1 + 1
<li>3 + 2
<li>4 + 1
<li>5
</ol>
<p>
The number of partitions of n is given by the partition function p(n). In
number theory, the partition function p(n) represents the number of possible
partitions of a natural number n, which is to say the number of distinct (and
order independent) ways of representing n as a sum of natural numbers.
<p>
Let's generate all possible partitions of 5:
<p>
<blockquote>

<pre>
// Create an instance of the partition generator to generate all
// possible partitions of 5
Generator&lt;Integer&gt; gen = Factory.createPartitionGenerator(5);

// Print the partitions
for (ICombinatoricsVector&lt;Integer&gt; p : gen) {
	System.out.println(p);
}
</pre>

</blockquote>
<p>
And the result of all 7 integer possible partitions
<p>
<blockquote>
<pre>
  CombinatoricsVector=([1, 1, 1, 1, 1], size=5)
  CombinatoricsVector=([2, 1, 1, 1], size=4)
  CombinatoricsVector=([2, 2, 1], size=3)
  CombinatoricsVector=([3, 1, 1], size=3)
  CombinatoricsVector=([3, 2], size=2)
  CombinatoricsVector=([4, 1], size=2)
  CombinatoricsVector=([5], size=1)
</pre>
</blockquote>
<p>

<h3>7. Integer compositions</h3>
A composition of an integer n is a way of writing n as the sum of a sequence
of (strictly) positive integers. This class generates the composition if a
positive integer value.
<p>
A composition of an integer n is a way of writing n as the sum of a sequence
of (strictly) positive integers. Two sequences that differ in the order of
their terms define different compositions of their sum, while they are
considered to define the same partition of that number.
<p>
The sixteen compositions of 5 are:
<ol>
<li>5
<li>4+1
<li>3+2
<li>3+1+1
<li>2+3
<li>2+2+1
<li>2+1+2
<li>2+1+1+1
<li>1+4
<li>1+3+1
<li>1+2+2
<li>1+2+1+1
<li>1+1+3
<li>1+1+2+1
<li>1+1+1+2
<li>1+1+1+1+1.
</ol>
<p>
Compare this with the seven partitions of 5:
<ol>
<li>5
<li>4+1
<li>3+2
<li>3+1+1
<li>2+2+1
<li>2+1+1+1
<li>1+1+1+1+1.
</ol>
<p>
Example. Generate compositions all possible integer compositions of 5.
<p>
<blockquote>

<pre>
  // Create an instance of the integer composition generator to generate all possible compositions of 5
  Generator&lt;Integer&gt; gen = Factory.createCompositionGenerator(5);

  // Print the compositions
  for (ICombinatoricsVector&lt;Integer&gt; p : gen) {
     System.out.println(p);
  }
</pre>

</blockquote>
<p>
And the result
<p>
<blockquote>

<pre>
   CombinatoricsVector=([5], size=1)
   CombinatoricsVector=([1, 4], size=2)
   CombinatoricsVector=([2, 3], size=2)
   CombinatoricsVector=([1, 1, 3], size=3)
   CombinatoricsVector=([3, 2], size=2)
   CombinatoricsVector=([1, 2, 2], size=3)
   CombinatoricsVector=([2, 1, 2], size=3)
   CombinatoricsVector=([1, 1, 1, 2], size=4)
   CombinatoricsVector=([4, 1], size=2)
   CombinatoricsVector=([1, 3, 1], size=3)
   CombinatoricsVector=([2, 2, 1], size=3)
   CombinatoricsVector=([1, 1, 2, 1], size=4)
   CombinatoricsVector=([3, 1, 1], size=3)
   CombinatoricsVector=([1, 2, 1, 1], size=4)
   CombinatoricsVector=([2, 1, 1, 1], size=4)
   CombinatoricsVector=([1, 1, 1, 1, 1], size=5)
</pre>

</blockquote>
<p>

<h3>8. List Partitions</h3>
<p>
It is possible to generate non-overlapping sublists of length <b>n</b> of a given <b>list</b>
<p>
For example, if a list is (A, B, B, C), then the non-overlapping sublists of length 2 will be: 
<ol>
<li>( (A), (B, B, C) )
<li>( (B, B, C), (A) )
<li>( (B), (A, B, C) )
<li>( (A, B, C), (B) )
<li>( (A, B), (B, C) )
<li>( (B, C), (A, B) )
<li>( (B, B), (A, C) )
<li>( (A, C), (B, B) )
<li>( (A, B, B), (C) )
<li>( (C), (A, B, B) ) 
</ol>
<p>
To do that you should use an instance of the complex combination generator 
<p>
<blockquote>
<pre>
  // create a vector (A, B, B, C)
  ICombinatoricsVector&lt;String&gt; vector = Factory.createVector(new String[] { "A", "B", "B", "C" });

  // Create a complex-combination generator
  Generator&lt;ICombinatoricsVector&lt;String&gt;&gt; gen = new ComplexCombinationGenerator&lt;String&gt;(vector, 2);

  // Iterate the combinations
  for (ICombinatoricsVector&lt;ICombinatoricsVector&lt;String&gt;&gt; comb : gen) {
     System.out.println(ComplexCombinationGenerator.convert2String(comb) + " - " + comb);
  }
</pre>

</blockquote>
<p>
And the result
<p>
<blockquote>

<pre>
 ([A],[B, B, C]) - CombinatoricsVector=([CombinatoricsVector=([A], size=1), CombinatoricsVector=([B, B, C], size=3)], size=2)
 ([B, B, C],[A]) - CombinatoricsVector=([CombinatoricsVector=([B, B, C], size=3), CombinatoricsVector=([A], size=1)], size=2)
 ([B],[A, B, C]) - CombinatoricsVector=([CombinatoricsVector=([B], size=1), CombinatoricsVector=([A, B, C], size=3)], size=2)
 ([A, B, C],[B]) - CombinatoricsVector=([CombinatoricsVector=([A, B, C], size=3), CombinatoricsVector=([B], size=1)], size=2)
 ([A, B],[B, C]) - CombinatoricsVector=([CombinatoricsVector=([A, B], size=2), CombinatoricsVector=([B, C], size=2)], size=2)
 ([B, C],[A, B]) - CombinatoricsVector=([CombinatoricsVector=([B, C], size=2), CombinatoricsVector=([A, B], size=2)], size=2)
 ([B, B],[A, C]) - CombinatoricsVector=([CombinatoricsVector=([B, B], size=2), CombinatoricsVector=([A, C], size=2)], size=2)
 ([A, C],[B, B]) - CombinatoricsVector=([CombinatoricsVector=([A, C], size=2), CombinatoricsVector=([B, B], size=2)], size=2)
 ([A, B, B],[C]) - CombinatoricsVector=([CombinatoricsVector=([A, B, B], size=3), CombinatoricsVector=([C], size=1)], size=2)
 ([C],[A, B, B]) - CombinatoricsVector=([CombinatoricsVector=([C], size=1), CombinatoricsVector=([A, B, B], size=3)], size=2)
</pre>

</blockquote>

</body>
</html>
